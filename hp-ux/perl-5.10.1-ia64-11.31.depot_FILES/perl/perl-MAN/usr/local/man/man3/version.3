.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "version 3"
.TH version 3 "2009-07-28" "perl v5.10.1" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
version \- Perl extension for Version Objects
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  # Parsing version strings (decimal or dotted\-decimal)
\&
\&  use version 0.77; # get latest bug\-fixes and API
\&  $ver = version\->parse($string)
\&
\&  # Declaring a dotted\-decimal $VERSION (keep on one line!)
\&
\&  use version 0.77; our $VERSION = version\->declare("v1.2.3"); # formal
\&  use version 0.77; our $VERSION = qv("v1.2.3");               # shorthand
\&  use version 0.77; our $VERSION = qv("v1.2_3");               # alpha
\&
\&  # Declaring an old\-style decimal $VERSION (use quotes!)
\&
\&  use version 0.77; our $VERSION = version\->parse("1.0203");   # formal
\&  use version 0.77; our $VERSION = version\->parse("1.02_03");  # alpha
\&
\&  # Comparing mixed version styles (decimals, dotted\-decimals, objects)
\&
\&  if ( version\->parse($v1) == version\->parse($v2) ) {
\&    # do stuff
\&  }
\&
\&  # Sorting mixed version styles
\&
\&  @ordered = sort { version\->parse($a) <=> version\->parse($b) } @list;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Version objects were added to Perl in 5.10.  This module implements version
objects for older version of Perl and provides the version object \s-1API\s0 for all
versions of Perl.  All previous releases before 0.74 are deprecated and should
not be used due to incompatible \s-1API\s0 changes.  Version 0.77 introduces the new
\&'parse' and 'declare' methods to standardize usage.  You are strongly urged to
set 0.77 as a minimum in your code, e.g.
.PP
.Vb 1
\&  use version 0.77; # even for Perl v.5.10.0
.Ve
.SH "TYPES OF VERSION OBJECTS"
.IX Header "TYPES OF VERSION OBJECTS"
There are two different types of version objects, corresponding to the two
different styles of versions in use:
.IP "Decimal Versions" 2
.IX Item "Decimal Versions"
The classic floating-point number \f(CW$VERSION\fR.  The advantage to this style is
that you don't need to do anything special, just type a number (without
quotes) into your source file.
.IP "Dotted Decimal Versions" 2
.IX Item "Dotted Decimal Versions"
The more modern form of version assignment, with 3 (or potentially more)
integers seperated by decimal points (e.g. v1.2.3).  This is the form that
Perl itself has used since 5.6.0 was released.  The leading \*(L"v\*(R" is now 
strongly recommended for clarity, and will throw a warning in a future
release if omitted.
.PP
See \*(L"\s-1VERSION\s0 \s-1OBJECT\s0 \s-1DETAILS\s0\*(R" for further information.
.SH "DECLARING VERSIONS"
.IX Header "DECLARING VERSIONS"
If you have a module that uses a decimal \f(CW$VERSION\fR (floating point), and you
do not intend to ever change that, this module is not for you.  There is
nothing that version.pm gains you over a simple \f(CW$VERSION\fR assignment:
.PP
.Vb 1
\&  our $VERSION = 1.02;
.Ve
.PP
Since Perl v5.10.0 includes the version.pm comparison logic anyways, 
you don't need to do anything at all.
.SS "How to convert a module from decimal to dotted-decimal"
.IX Subsection "How to convert a module from decimal to dotted-decimal"
If you have used a decimal \f(CW$VERSION\fR in the past and wish to switch to a
dotted-decimal \f(CW$VERSION\fR, then you need to make a one-time conversion to
the new format.
.PP
\&\fBImportant Note\fR: you must ensure that your new \f(CW$VERSION\fR is numerically
greater than your current decimal \f(CW$VERSION\fR; this is not always obvious. First,
convert your old decimal version (e.g. 1.02) to a normalized dotted-decimal
form:
.PP
.Vb 2
\&  $ perl \-Mversion \-e \*(Aqprint version\->parse("1.02")\->normal\*(Aq
\&  v1.20.0
.Ve
.PP
Then increment any of the dotted-decimal components (v1.20.1 or v1.21.0).
.ie n .SS "How to ""declare()"" a dotted-decimal version"
.el .SS "How to \f(CWdeclare()\fP a dotted-decimal version"
.IX Subsection "How to declare() a dotted-decimal version"
.Vb 1
\&  use version 0.77; our $VERSION = version\->declare("v1.2.3");
.Ve
.PP
The \f(CW\*(C`declare()\*(C'\fR method always creates dotted-decimal version objects.  When
used in a module, you \fBmust\fR put it on the same line as \*(L"use version\*(R" to
ensure that \f(CW$VERSION\fR is read correctly by \s-1PAUSE\s0 and installer tools.  You
should also add 'version' to the 'configure_requires' section of your
module metadata file.  See instructions in ExtUtils::MakeMaker or
Module::Build for details.
.PP
\&\fBImportant Note\fR: Even if you pass in what looks like a decimal number
(\*(L"1.2\*(R"), a dotted-decimal will be created (\*(L"v1.200.0\*(R"). To avoid confusion
or unintentional errors on older Perls, follow these guidelines:
.IP "\(bu" 2
Always use a dotted-decimal with (at least) three components
.IP "\(bu" 2
Always use a leading-v
.IP "\(bu" 2
Always quote the version
.PP
If you really insist on using version.pm with an ordinary decimal version,
use \f(CW\*(C`parse()\*(C'\fR instead of declare.  See the \*(L"\s-1PARSING\s0 \s-1AND\s0 \s-1COMPARING\s0 \s-1VERSIONS\s0\*(R"
for details.
.PP
See also \*(L"\s-1VERSION\s0 \s-1OBJECT\s0 \s-1DETAILS\s0\*(R" for more on version number conversion,
quoting, calculated version numbers and declaring developer or \*(L"alpha\*(R" version
numbers.
.SH "PARSING AND COMPARING VERSIONS"
.IX Header "PARSING AND COMPARING VERSIONS"
If you need to compare version numbers, but can't be sure whether they are
expressed as numbers, strings, v\-strings or version objects,  then you can
use version.pm to parse them all into objects for comparison.
.ie n .SS "How to ""parse()"" a version"
.el .SS "How to \f(CWparse()\fP a version"
.IX Subsection "How to parse() a version"
The \f(CW\*(C`parse()\*(C'\fR method takes in anything that might be a version and returns
a corresponding version object, doing any necessary conversion along the way.
.IP "\(bu" 2
Dotted-decimal: bare v\-strings (v1.2.3) and strings with more than one
decimal point and a leading 'v' (\*(L"v1.2.3\*(R"); \s-1NOTE\s0 you can technically use a
v\-string or strings with a leading-v and only one decimal point (v1.2 or
\&\*(L"v1.2\*(R"), but you will confuse both yourself and others.
.IP "\(bu" 2
Decimal: regular decimal numbers (literal or in a string)
.PP
Some examples:
.PP
.Vb 8
\&  $variable   version\->parse($variable)
\&  \-\-\-\-\-\-\-\-\-   \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  1.23        v1.230.0
\&  "1.23"      v1.230.0
\&  v1.23       v1.23.0
\&  "v1.23"     v1.23.0
\&  "1.2.3"     v1.2.3
\&  "v1.2.3"    v1.2.3
.Ve
.PP
See \*(L"\s-1VERSION\s0 \s-1OBJECT\s0 \s-1DETAILS\s0\*(R" for more on version number conversion.
.SS "How to compare version objects"
.IX Subsection "How to compare version objects"
Version objects overload the \f(CW\*(C`cmp\*(C'\fR and \f(CW\*(C`<=>\*(C'\fR operators.  Perl
automatically generates all of the other comparison operators based on those
two so all the normal logical comparisons will work.
.PP
.Vb 3
\&  if ( version\->parse($v1) == version\->parse($v2) ) {
\&    # do stuff
\&  }
.Ve
.PP
If a version object is compared against a non-version object, the non-object
term will be converted to a version object using \f(CW\*(C`parse()\*(C'\fR.  This may give
surprising results:
.PP
.Vb 2
\&  $v1 = version\->parse("v0.95.0");
\&  $bool = $v1 < 0.96; # FALSE since 0.96 is v0.960.0
.Ve
.PP
Always comparing to a version object will help avoid surprises:
.PP
.Vb 1
\&  $bool = $v1 < version\->parse("v0.96.0"); # TRUE
.Ve
.SH "VERSION OBJECT DETAILS"
.IX Header "VERSION OBJECT DETAILS"
.SS "Equivalence between Decimal and Dotted-Decimal Versions"
.IX Subsection "Equivalence between Decimal and Dotted-Decimal Versions"
When Perl 5.6.0 was released, the decision was made to provide a
transformation between the old-style decimal versions and new-style
dotted-decimal versions:
.PP
.Vb 2
\&  5.6.0    == 5.006000
\&  5.005_04 == 5.5.40
.Ve
.PP
The floating point number is taken and split first on the single decimal
place, then each group of three digits to the right of the decimal makes up
the next digit, and so on until the number of significant digits is exhausted,
\&\fBplus\fR enough trailing zeros to reach the next multiple of three.
.PP
This was the method that version.pm adopted as well.  Some examples may be
helpful:
.PP
.Vb 9
\&                            equivalent
\&  decimal    zero\-padded    dotted\-decimal
\&  \-\-\-\-\-\-\-    \-\-\-\-\-\-\-\-\-\-\-    \-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  1.2        1.200          v1.200.0
\&  1.02       1.020          v1.20.0
\&  1.002      1.002          v1.2.0
\&  1.0023     1.002300       v1.2.300
\&  1.00203    1.002030       v1.2.30
\&  1.002003   1.002003       v1.2.3
.Ve
.SS "Quoting rules"
.IX Subsection "Quoting rules"
Because of the nature of the Perl parsing and tokenizing routines,
certain initialization values \fBmust\fR be quoted in order to correctly
parse as the intended version, especially when using the declare or
qv methods.  While you do not have to quote decimal numbers when
creating version objects, it is always safe to quote \fBall\fR initial values
when using version.pm methods, as this will ensure that what you type is
what is used.
.PP
Additionally, if you quote your initializer, then the quoted value that goes
\&\fBin\fR will be be exactly what comes \fBout\fR when your \f(CW$VERSION\fR is printed
(stringified).  If you do not quote your value, Perl's normal numeric handling
comes into play and you may not get back what you were expecting.
.PP
If you use a mathematic formula that resolves to a floating point number,
you are dependent on Perl's conversion routines to yield the version you
expect.  You are pretty safe by dividing by a power of 10, for example,
but other operations are not likely to be what you intend.  For example:
.PP
.Vb 4
\&  $VERSION = version\->new((qw$Revision: 1.4)[1]/10);
\&  print $VERSION;          # yields 0.14
\&  $V2 = version\->new(100/9); # Integer overflow in decimal number
\&  print $V2;               # yields something like 11.111.111.100
.Ve
.PP
Perl 5.8.1 and beyond are able to automatically quote v\-strings but
that is not possible in earlier versions of Perl.  In other words:
.PP
.Vb 2
\&  $version = version\->new("v2.5.4");  # legal in all versions of Perl
\&  $newvers = version\->new(v2.5.4);    # legal only in Perl >= 5.8.1
.Ve
.SS "What about v\-strings?"
.IX Subsection "What about v-strings?"
There are two ways to enter v\-strings: a bare number with two or more
decimal points, or a bare number with one or more decimal points and a 
leading 'v' character (also bare).  For example:
.PP
.Vb 2
\&  $vs1 = 1.2.3; # encoded as \e1\e2\e3
\&  $vs2 = v1.2;  # encoded as \e1\e2
.Ve
.PP
However, the use of bare v\-strings to initialize version objects is
\&\fBstrongly\fR discouraged in all circumstances.  Also, bare
v\-strings are not completely supported in any version of Perl prior to
5.8.1.
.PP
If you insist on using bare v\-strings with Perl > 5.6.0, be aware of the 
following limitations:
.PP
1) For Perl releases 5.6.0 through 5.8.0, the v\-string code merely guesses, 
based on some characteristics of v\-strings.  You \fBmust\fR use a three part
version, e.g. 1.2.3 or v1.2.3 in order for this heuristic to be successful.
.PP
2) For Perl releases 5.8.1 and later, v\-strings have changed in the Perl
core to be magical, which means that the version.pm code can automatically
determine whether the v\-string encoding was used.
.PP
3) In all cases, a version created using v\-strings will have a stringified
form that has a leading 'v' character, for the simple reason that sometimes
it is impossible to tell whether one was present initially.
.SS "Alpha versions"
.IX Subsection "Alpha versions"
For module authors using \s-1CPAN\s0, the convention has been to note unstable
releases with an underscore in the version string. (See \s-1CPAN\s0.)  version.pm
follows this convention and alpha releases will test as being newer than the
more recent stable release, and less than the next stable release.  For
dotted-decimal versions, only the last element may be separated by an
underscore:
.PP
.Vb 2
\&  # Declaring
\&  use version 0.77; our $VERSION = version\->declare("v1.2_3");
\&
\&  # Parsing
\&  $v1 = version\->parse("v1.2_3");
\&  $v1 = version\->parse("1.002_003");
.Ve
.SH "OBJECT METHODS"
.IX Header "OBJECT METHODS"
.SS "\fIis_alpha()\fP"
.IX Subsection "is_alpha()"
True if and only if the version object was created with a underscore, e.g.
.PP
.Vb 2
\&  version\->parse(\*(Aq1.002_03\*(Aq)\->is_alpha;  # TRUE
\&  version\->declare(\*(Aq1.2.3_4\*(Aq)\->is_alpha; # TRUE
.Ve
.SS "\fIis_qv()\fP"
.IX Subsection "is_qv()"
True only if the version object is a dotted-decimal version, e.g.
.PP
.Vb 4
\&  version\->parse(\*(Aqv1.2.0\*(Aq)\->is_qv;        # TRUE
\&  version\->declare(\*(Aqv1.2\*(Aq)\->is_qv;       # TRUE
\&  qv(\*(Aq1.2\*(Aq)\->is_qv;                      # TRUE
\&  version\->parse(\*(Aq1.2\*(Aq)\->is_qv;          # FALSE
.Ve
.SS "\fInormal()\fP"
.IX Subsection "normal()"
Returns a string with a standard 'normalized' dotted-decimal form with a
leading-v and at least 3 components.
.PP
.Vb 2
\& version\->declare(\*(Aqv1.2\*(Aq)\->normal;  # v1.2.0
\& version\->parse(\*(Aq1.2\*(Aq)\->normal;     # v1.200.0
.Ve
.SS "\fInumify()\fP"
.IX Subsection "numify()"
Returns a value representing the object in a pure decimal form without
trailing zeroes.
.PP
.Vb 2
\& version\->declare(\*(Aqv1.2\*(Aq)\->numify;  # 1.002
\& version\->parse(\*(Aq1.2\*(Aq)\->numify;     # 1.2
.Ve
.SS "\fIstringify()\fP"
.IX Subsection "stringify()"
Returns a string that is as close to the original representation as possible.
If the original representation was a numeric literal, it will be returned the
way perl would normally represent it in a string.  This method is used whenever
a version object is interpolated into a string.
.PP
.Vb 3
\& version\->declare(\*(Aqv1.2\*(Aq)\->stringify;    # v1.2
\& version\->parse(\*(Aq1.200\*(Aq)\->stringify;     # 1.200
\& version\->parse(1.02_30)\->stringify;     # 1.023
.Ve
.SH "EXPORTED FUNCTIONS"
.IX Header "EXPORTED FUNCTIONS"
.SS "\fIqv()\fP"
.IX Subsection "qv()"
This function is no longer recommended for use, but is maintained for
compatibility with existing code.  If you do not want to have it exported
to your namespace, use this form:
.PP
.Vb 1
\&  use version 0.77 ();
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
John Peacock <jpeacock@cpan.org>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
version::Internal.
.PP
perl.
