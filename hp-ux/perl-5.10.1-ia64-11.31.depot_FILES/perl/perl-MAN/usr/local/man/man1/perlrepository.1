.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLREPOSITORY 1"
.TH PERLREPOSITORY 1 "2009-08-03" "perl v5.10.1" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlrepository \- Using the Perl source repository
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
All of Perl's source code is kept centrally in a Git repository at
\&\fIperl5.git.perl.org\fR. The repository contains many Perl revisions from
Perl 1 onwards and all the revisions from Perforce, the version control
system we were using previously. This repository is accessible in
different ways.
.PP
The full repository takes up about 80MB of disk space. A check out of
the blead branch (that is, the main development branch, which contains
bleadperl, the development version of perl 5) takes up about 160MB of
disk space (including the repository). A build of bleadperl takes up
about 200MB (including the repository and the check out).
.SH "GETTING ACCESS TO THE REPOSITORY"
.IX Header "GETTING ACCESS TO THE REPOSITORY"
.SS "\s-1READ\s0 \s-1ACCESS\s0 \s-1VIA\s0 \s-1THE\s0 \s-1WEB\s0"
.IX Subsection "READ ACCESS VIA THE WEB"
You may access the repository over the web. This allows you to browse
the tree, see recent commits, subscribe to \s-1RSS\s0 feeds for the changes,
search for particular commits and more. You may access it at:
.PP
.Vb 1
\&  http://perl5.git.perl.org/perl.git
.Ve
.PP
A mirror of the repository is found at:
.PP
.Vb 1
\&  http://github.com/github/perl
.Ve
.SS "\s-1READ\s0 \s-1ACCESS\s0 \s-1VIA\s0 \s-1GIT\s0"
.IX Subsection "READ ACCESS VIA GIT"
You will need a copy of Git for your computer. You can fetch a copy of
the repository using the Git protocol (which uses port 9418):
.PP
.Vb 1
\&  git clone git://perl5.git.perl.org/perl.git perl\-git
.Ve
.PP
This clones the repository and makes a local copy in the \fIperl-git\fR
directory.
.PP
If your local network does not allow you to use port 9418, then you can
fetch a copy of the repository over \s-1HTTP\s0 (this is slower):
.PP
.Vb 1
\&  git clone http://perl5.git.perl.org/perl.git perl\-http
.Ve
.PP
This clones the repository and makes a local copy in the \fIperl-http\fR
directory.
.SS "\s-1WRITE\s0 \s-1ACCESS\s0 \s-1TO\s0 \s-1THE\s0 \s-1REPOSITORY\s0"
.IX Subsection "WRITE ACCESS TO THE REPOSITORY"
If you are a committer, then you can fetch a copy of the repository
that you can push back on with:
.PP
.Vb 1
\&  git clone ssh://perl5.git.perl.org/gitroot/perl.git perl\-ssh
.Ve
.PP
This clones the repository and makes a local copy in the \fIperl-ssh\fR
directory.
.PP
If you cloned using the git protocol, which is faster than ssh, then
you will need to modify your config in order to enable pushing. Edit
\&\fI.git/config\fR where you will see something like:
.PP
.Vb 2
\&  [remote "origin"]
\&  url = git://perl5.git.perl.org/perl.git
.Ve
.PP
change that to something like this:
.PP
.Vb 2
\&  [remote "origin"]
\&  url = ssh://perl5.git.perl.org/gitroot/perl.git
.Ve
.PP
\&\s-1NOTE:\s0 there are symlinks set up so that the /gitroot is optional and
since \s-1SSH\s0 is the default protocol you can actually shorten the \*(L"url\*(R" to
\&\f(CW\*(C`perl5.git.perl.org:/perl.git\*(C'\fR.
.PP
You can also set up your user name and e\-mail address. For example
.PP
.Vb 2
\&  % git config user.name "Leon Brocard"
\&  % git config user.email acme@astray.com
.Ve
.PP
It is also possible to keep \f(CW\*(C`origin\*(C'\fR as a git remote, and add a new
remote for ssh access:
.PP
.Vb 1
\&  % git remote add camel perl5.git.perl.org:/perl.git
.Ve
.PP
This allows you to update your local repository by pulling from
\&\f(CW\*(C`origin\*(C'\fR, which is faster and doesn't require you to authenticate, and
to push your changes back with the \f(CW\*(C`camel\*(C'\fR remote:
.PP
.Vb 2
\&  % git fetch camel
\&  % git push camel
.Ve
.PP
The \f(CW\*(C`fetch\*(C'\fR command just updates the \f(CW\*(C`camel\*(C'\fR refs, as the objects
themselves should have been fetched when pulling from \f(CW\*(C`origin\*(C'\fR.
.PP
The committers have access to 2 servers that serve perl5.git.perl.org.
One is camel.booking.com, which is the 'master' repository. The
perl5.git.perl.org \s-1IP\s0 address also lives on this machine. The second
one is dromedary.booking.com, which can be used for general testing and
development. Dromedary syncs the git tree from camel every few minutes,
you should not push there. Both machines also have a full \s-1CPAN\s0 mirror.
To share files with the general public, dromedary serves your
~/public_html/ as http://users.perl5.git.perl.org/~yourlogin/
.SH "OVERVIEW OF THE REPOSITORY"
.IX Header "OVERVIEW OF THE REPOSITORY"
Once you have changed into the repository directory, you can inspect
it.
.PP
After a clone the repository will contain a single local branch, which
will be the current branch as well, as indicated by the asterisk.
.PP
.Vb 2
\&  % git branch
\&  * blead
.Ve
.PP
Using the \-a switch to \f(CW\*(C`branch\*(C'\fR will also show the remote tracking
branches in the repository:
.PP
.Vb 5
\&  % git branch \-a
\&  * blead
\&    origin/HEAD
\&    origin/blead
\&  ...
.Ve
.PP
The branches that begin with \*(L"origin\*(R" correspond to the \*(L"git remote\*(R"
that you cloned from (which is named \*(L"origin\*(R"). Each branch on the
remote will be exactly tracked by theses branches. You should \s-1NEVER\s0 do
work on these remote tracking branches. You only ever do work in a
local branch. Local branches can be configured to automerge (on pull)
from a designated remote tracking branch. This is the case with the
default branch \f(CW\*(C`blead\*(C'\fR which will be configured to merge from the
remote tracking branch \f(CW\*(C`origin/blead\*(C'\fR.
.PP
You can see recent commits:
.PP
.Vb 1
\&  % git log
.Ve
.PP
And pull new changes from the repository, and update your local
repository (must be clean first)
.PP
.Vb 1
\&  % git pull
.Ve
.PP
Assuming we are on the branch \f(CW\*(C`blead\*(C'\fR immediately after a pull, this
command would be more or less equivalent to:
.PP
.Vb 2
\&  % git fetch
\&  % git merge origin/blead
.Ve
.PP
In fact if you want to update your local repository without touching
your working directory you do:
.PP
.Vb 1
\&  % git fetch
.Ve
.PP
And if you want to update your remote-tracking branches for all defined
remotes simultaneously you can do
.PP
.Vb 1
\&  % git remote update
.Ve
.PP
Neither of these last two commands will update your working directory,
however both will update the remote-tracking branches in your
repository.
.PP
To switch to another branch:
.PP
.Vb 1
\&  % git checkout origin/maint\-5.8\-dor
.Ve
.PP
To make a local branch of a remote branch:
.PP
.Vb 1
\&  % git checkout \-b maint\-5.10 origin/maint\-5.10
.Ve
.PP
To switch back to blead:
.PP
.Vb 1
\&  % git checkout blead
.Ve
.SS "\s-1FINDING\s0 \s-1OUT\s0 \s-1YOUR\s0 \s-1STATUS\s0"
.IX Subsection "FINDING OUT YOUR STATUS"
The most common git command you will use will probably be
.PP
.Vb 1
\&  % git status
.Ve
.PP
This command will produce as output a description of the current state
of the repository, including modified files and unignored untracked
files, and in addition it will show things like what files have been
staged for the next commit, and usually some useful information about
how to change things. For instance the following:
.PP
.Vb 10
\&  $ git status
\&  # On branch blead
\&  # Your branch is ahead of \*(Aqorigin/blead\*(Aq by 1 commit.
\&  #
\&  # Changes to be committed:
\&  #   (use "git reset HEAD <file>..." to unstage)
\&  #
\&  #       modified:   pod/perlrepository.pod
\&  #
\&  # Changed but not updated:
\&  #   (use "git add <file>..." to update what will be committed)
\&  #
\&  #       modified:   pod/perlrepository.pod
\&  #
\&  # Untracked files:
\&  #   (use "git add <file>..." to include in what will be committed)
\&  #
\&  #       deliberate.untracked
.Ve
.PP
This shows that there were changes to this document staged for commit,
and that there were further changes in the working directory not yet
staged. It also shows that there was an untracked file in the working
directory, and as you can see shows how to change all of this. It also
shows that there is one commit on the working branch \f(CW\*(C`blead\*(C'\fR which has
not been pushed to the \f(CW\*(C`origin\*(C'\fR remote yet. \fB\s-1NOTE\s0\fR: that this output
is also what you see as a template if you do not provide a message to
\&\f(CW\*(C`git commit\*(C'\fR.
.PP
Assuming we commit all the mentioned changes above:
.PP
.Vb 3
\&  % git commit \-a \-m\*(Aqexplain git status and stuff about remotes\*(Aq
\&  Created commit daf8e63: explain git status and stuff about remotes
\&   1 files changed, 83 insertions(+), 3 deletions(\-)
.Ve
.PP
We can re-run git status and see something like this:
.PP
.Vb 9
\&  % git status
\&  # On branch blead
\&  # Your branch is ahead of \*(Aqorigin/blead\*(Aq by 2 commits.
\&  #
\&  # Untracked files:
\&  #   (use "git add <file>..." to include in what will be committed)
\&  #
\&  #       deliberate.untracked
\&  nothing added to commit but untracked files present (use "git add" to track)
.Ve
.PP
When in doubt, before you do anything else, check your status and read
it carefully, many questions are answered directly by the git status
output.
.SH "SUBMITTING A PATCH"
.IX Header "SUBMITTING A PATCH"
If you have a patch in mind for Perl, you should first get a copy of
the repository:
.PP
.Vb 1
\&  % git clone git://perl5.git.perl.org/perl.git perl\-git
.Ve
.PP
Then change into the directory:
.PP
.Vb 1
\&  % cd perl\-git
.Ve
.PP
Alternatively, if you already have a Perl repository, you should ensure
that you're on the \fIblead\fR branch, and your repository is up to date:
.PP
.Vb 2
\&  % git checkout blead
\&  % git pull
.Ve
.PP
It's preferable to patch against the latest blead version, since this
is where new development occurs for all changes other than critical bug
fixes.  Critical bug fix patches should be made against the relevant
maint branches, or should be submitted with a note indicating all the
branches where the fix should be applied.
.PP
Now that we have everything up to date, we need to create a temporary
new branch for these changes and switch into it:
.PP
.Vb 1
\&  % git checkout \-b orange
.Ve
.PP
which is the short form of
.PP
.Vb 2
\&  % git branch orange
\&  % git checkout orange
.Ve
.PP
Then make your changes. For example, if Leon Brocard changes his name
to Orange Brocard, we should change his name in the \s-1AUTHORS\s0 file:
.PP
.Vb 1
\&  % perl \-pi \-e \*(Aqs{Leon Brocard}{Orange Brocard}\*(Aq AUTHORS
.Ve
.PP
You can see what files are changed:
.PP
.Vb 7
\&  % git status
\&  # On branch orange
\&  # Changes to be committed:
\&  #   (use "git reset HEAD <file>..." to unstage)
\&  #
\&  #     modified:   AUTHORS
\&  #
.Ve
.PP
And you can see the changes:
.PP
.Vb 10
\&  % git diff
\&  diff \-\-git a/AUTHORS b/AUTHORS
\&  index 293dd70..722c93e 100644
\&  \-\-\- a/AUTHORS
\&  +++ b/AUTHORS
\&  @@ \-541,7 +541,7 @@    Lars Hecking                   <lhecking@nmrc.ucc.ie>
\&   Laszlo Molnar                  <laszlo.molnar@eth.ericsson.se>
\&   Leif Huhn                      <leif@hale.dkstat.com>
\&   Len Johnson                    <lenjay@ibm.net>
\&  \-Leon Brocard                   <acme@astray.com>
\&  +Orange Brocard                 <acme@astray.com>
\&   Les Peters                     <lpeters@aol.net>
\&   Lesley Binks                   <lesley.binks@gmail.com>
\&   Lincoln D. Stein               <lstein@cshl.org>
.Ve
.PP
Now commit your change locally:
.PP
.Vb 3
\&  % git commit \-a \-m \*(AqRename Leon Brocard to Orange Brocard\*(Aq
\&  Created commit 6196c1d: Rename Leon Brocard to Orange Brocard
\&   1 files changed, 1 insertions(+), 1 deletions(\-)
.Ve
.PP
You can examine your last commit with:
.PP
.Vb 1
\&  % git show HEAD
.Ve
.PP
and if you are not happy with either the description or the patch
itself you can fix it up by editing the files once more and then issue:
.PP
.Vb 1
\&  % git commit \-a \-\-amend
.Ve
.PP
Now you should create a patch file for all your local changes:
.PP
.Vb 2
\&  % git format\-patch origin
\&  0001\-Rename\-Leon\-Brocard\-to\-Orange\-Brocard.patch
.Ve
.PP
You should now send an email to perl5\-porters@perl.org with a
description of your changes, and include this patch file as an
attachment.
.PP
If you want to delete your temporary branch, you may do so with:
.PP
.Vb 6
\&  % git checkout blead
\&  % git branch \-d orange
\&  error: The branch \*(Aqorange\*(Aq is not an ancestor of your current HEAD.
\&  If you are sure you want to delete it, run \*(Aqgit branch \-D orange\*(Aq.
\&  % git branch \-D orange
\&  Deleted branch orange.
.Ve
.SS "A note on derived files"
.IX Subsection "A note on derived files"
Be aware that many files in the distribution are derivative\*(--avoid
patching them, because git won't see the changes to them, and the build
process will overwrite them. Patch the originals instead.  Most
utilities (like perldoc) are in this category, i.e. patch
utils/perldoc.PL rather than utils/perldoc. Similarly, don't create
patches for files under \f(CW$src_root\fR/ext from their copies found in
\&\f(CW$install_root\fR/lib.  If you are unsure about the proper location of a
file that may have gotten copied while building the source
distribution, consult the \f(CW\*(C`MANIFEST\*(C'\fR.
.SS "A note on binary files"
.IX Subsection "A note on binary files"
Since the \fIpatch\fR\|(1) utility cannot deal with binary files, it's
important that you either avoid the use of binary files in your patch,
generate the files dynamically, or that you encode any binary files
using the \fIuupacktool.pl\fR utility.
.PP
Assuming you needed to include a gzip-encoded file for a module's test
suite, you might do this as follows using the \fIuupacktool.pl\fR utility:
.PP
.Vb 2
\&    $ perl uupacktool.pl \-v \-p \-D lib/Some/Module/t/src/t.gz
\&    Writing lib/Some/Module/t/src/t.gz into lib/Some/Module/t/src/t.gz.packed
.Ve
.PP
This will replace the \f(CW\*(C`t.gz\*(C'\fR file with an encoded counterpart. During
\&\f(CW\*(C`make test\*(C'\fR, before any tests are run, perl's Makefile will restore
all the \f(CW\*(C`.packed\*(C'\fR files mentioned in the \s-1MANIFEST\s0 to their original
name. This means that the test suite does not need to be aware of this
packing scheme and will not need to be altered.
.SS "Getting your patch accepted"
.IX Subsection "Getting your patch accepted"
The first thing you should include with your patch is a description of
the problem that the patch corrects.  If it is a code patch (rather
than a documentation patch) you should also include a small test case
that illustrates the bug (a patch to an existing test file is
preferred).
.PP
If you are submitting a code patch there are several other things that
you need to do.
.IP "Comments, Comments, Comments" 4
.IX Item "Comments, Comments, Comments"
Be sure to adequately comment your code.  While commenting every line
is unnecessary, anything that takes advantage of side effects of
operators, that creates changes that will be felt outside of the
function being patched, or that others may find confusing should be
documented.  If you are going to err, it is better to err on the side
of adding too many comments than too few.
.IP "Style" 4
.IX Item "Style"
In general, please follow the particular style of the code you are
patching.
.Sp
In particular, follow these general guidelines for patching Perl
sources:
.Sp
.Vb 10
\&    8\-wide tabs (no exceptions!)
\&    4\-wide indents for code, 2\-wide indents for nested CPP #defines
\&    try hard not to exceed 79\-columns
\&    ANSI C prototypes
\&    uncuddled elses and "K&R" style for indenting control constructs
\&    no C++ style (//) comments
\&    mark places that need to be revisited with XXX (and revisit often!)
\&    opening brace lines up with "if" when conditional spans multiple
\&        lines; should be at end\-of\-line otherwise
\&    in function definitions, name starts in column 0 (return value is on
\&        previous line)
\&    single space after keywords that are followed by parens, no space
\&        between function name and following paren
\&    avoid assignments in conditionals, but if they\*(Aqre unavoidable, use
\&        extra paren, e.g. "if (a && (b = c)) ..."
\&    "return foo;" rather than "return(foo);"
\&    "if (!foo) ..." rather than "if (foo == FALSE) ..." etc.
.Ve
.IP "Testsuite" 4
.IX Item "Testsuite"
When submitting a patch you should make every effort to also include an
addition to perl's regression tests to properly exercise your patch. 
Your testsuite additions should generally follow these guidelines
(courtesy of Gurusamy Sarathy <gsar@activestate.com>):
.Sp
.Vb 10
\&    Know what you\*(Aqre testing.  Read the docs, and the source.
\&    Tend to fail, not succeed.
\&    Interpret results strictly.
\&    Use unrelated features (this will flush out bizarre interactions).
\&    Use non\-standard idioms (otherwise you are not testing TIMTOWTDI).
\&    Avoid using hardcoded test numbers whenever possible (the
\&      EXPECTED/GOT found in t/op/tie.t is much more maintainable,
\&      and gives better failure reports).
\&    Give meaningful error messages when a test fails.
\&    Avoid using qx// and system() unless you are testing for them.  If you
\&      do use them, make sure that you cover _all_ perl platforms.
\&    Unlink any temporary files you create.
\&    Promote unforeseen warnings to errors with $SIG{_\|_WARN_\|_}.
\&    Be sure to use the libraries and modules shipped with the version
\&      being tested, not those that were already installed.
\&    Add comments to the code explaining what you are testing for.
\&    Make updating the \*(Aq1..42\*(Aq string unnecessary.  Or make sure that
\&      you update it.
\&    Test _all_ behaviors of a given operator, library, or function:
\&      \- All optional arguments
\&      \- Return values in various contexts (boolean, scalar, list, lvalue)
\&      \- Use both global and lexical variables
\&      \- Don\*(Aqt forget the exceptional, pathological cases.
.Ve
.SH "ACCEPTING A PATCH"
.IX Header "ACCEPTING A PATCH"
If you have received a patch file generated using the above section,
you should try out the patch.
.PP
First we need to create a temporary new branch for these changes and
switch into it:
.PP
.Vb 1
\&  % git checkout \-b experimental
.Ve
.PP
Patches that were formatted by \f(CW\*(C`git format\-patch\*(C'\fR are applied with
\&\f(CW\*(C`git am\*(C'\fR:
.PP
.Vb 2
\&  % git am 0001\-Rename\-Leon\-Brocard\-to\-Orange\-Brocard.patch
\&  Applying Rename Leon Brocard to Orange Brocard
.Ve
.PP
If just a raw diff is provided, it is also possible use this two-step
process:
.PP
.Vb 2
\&  % git apply bugfix.diff
\&  % git commit \-a \-m "Some fixing" \-\-author="That Guy <that.guy@internets.com>"
.Ve
.PP
Now we can inspect the change:
.PP
.Vb 4
\&  % git show HEAD
\&  commit b1b3dab48344cff6de4087efca3dbd63548ab5e2
\&  Author: Leon Brocard <acme@astray.com>
\&  Date:   Fri Dec 19 17:02:59 2008 +0000
\&
\&    Rename Leon Brocard to Orange Brocard
\&
\&  diff \-\-git a/AUTHORS b/AUTHORS
\&  index 293dd70..722c93e 100644
\&  \-\-\- a/AUTHORS
\&  +++ b/AUTHORS
\&  @@ \-541,7 +541,7 @@ Lars Hecking                        <lhecking@nmrc.ucc.ie>
\&   Laszlo Molnar                  <laszlo.molnar@eth.ericsson.se>
\&   Leif Huhn                      <leif@hale.dkstat.com>
\&   Len Johnson                    <lenjay@ibm.net>
\&  \-Leon Brocard                   <acme@astray.com>
\&  +Orange Brocard                 <acme@astray.com>
\&   Les Peters                     <lpeters@aol.net>
\&   Lesley Binks                   <lesley.binks@gmail.com>
\&   Lincoln D. Stein               <lstein@cshl.org>
.Ve
.PP
If you are a committer to Perl and you think the patch is good, you can
then merge it into blead then push it out to the main repository:
.PP
.Vb 3
\&  % git checkout blead
\&  % git merge experimental
\&  % git push
.Ve
.PP
If you want to delete your temporary branch, you may do so with:
.PP
.Vb 6
\&  % git checkout blead
\&  % git branch \-d experimental
\&  error: The branch \*(Aqexperimental\*(Aq is not an ancestor of your current HEAD.
\&  If you are sure you want to delete it, run \*(Aqgit branch \-D experimental\*(Aq.
\&  % git branch \-D experimental
\&  Deleted branch experimental.
.Ve
.SH "CLEANING A WORKING DIRECTORY"
.IX Header "CLEANING A WORKING DIRECTORY"
The command \f(CW\*(C`git clean\*(C'\fR can with varying arguments be used as a
replacement for \f(CW\*(C`make clean\*(C'\fR.
.PP
To reset your working directory to a pristine condition you can do:
.PP
.Vb 1
\&  git clean \-dxf
.Ve
.PP
However, be aware this will delete \s-1ALL\s0 untracked content. You can use
.PP
.Vb 1
\&  git clean \-Xf
.Ve
.PP
to remove all ignored untracked files, such as build and test
byproduct, but leave any  manually created files alone.
.PP
If you only want to cancel some uncommitted edits, you can use \f(CW\*(C`git
checkout\*(C'\fR and give it a list of files to be reverted, or \f(CW\*(C`git checkout
\&\-f\*(C'\fR to revert them all.
.PP
If you want to cancel one or several commits, you can use \f(CW\*(C`git reset\*(C'\fR.
.SH "BISECTING"
.IX Header "BISECTING"
\&\f(CW\*(C`git\*(C'\fR provides a built-in way to determine, with a binary search in
the history, which commit should be blamed for introducing a given bug.
.PP
Suppose that we have a script \fI~/testcase.pl\fR that exits with \f(CW0\fR
when some behaviour is correct, and with \f(CW1\fR when it's faulty. We need
an helper script that automates building \f(CW\*(C`perl\*(C'\fR and running the
testcase:
.PP
.Vb 10
\&  % cat ~/run
\&  #!/bin/sh
\&  git clean \-dxf
\&  # If you can use ccache, add \-Dcc=ccache\e gcc \-Dld=gcc to the Configure line
\&  sh Configure \-des \-Dusedevel \-Doptimize="\-g"
\&  test \-f config.sh || exit 125
\&  # Correct makefile for newer GNU gcc
\&  perl \-ni \-we \*(Aqprint unless /<(?:built\-in|command)/\*(Aq makefile x2p/makefile
\&  # if you just need miniperl, replace test_prep with miniperl
\&  make \-j4 test_prep
\&  \-x ./perl || exit 125
\&  ./perl \-Ilib ~/testcase.pl
\&  ret=$?
\&  git clean \-dxf
\&  exit $ret
.Ve
.PP
This script may return \f(CW125\fR to indicate that the corresponding commit
should be skipped. Otherwise, it returns the status of
\&\fI~/testcase.pl\fR.
.PP
We first enter in bisect mode with:
.PP
.Vb 1
\&  % git bisect start
.Ve
.PP
For example, if the bug is present on \f(CW\*(C`HEAD\*(C'\fR but wasn't in 5.10.0,
\&\f(CW\*(C`git\*(C'\fR will learn about this when you enter:
.PP
.Vb 3
\&  % git bisect bad
\&  % git bisect good perl\-5.10.0
\&  Bisecting: 853 revisions left to test after this
.Ve
.PP
This results in checking out the median commit between \f(CW\*(C`HEAD\*(C'\fR and
\&\f(CW\*(C`perl\-5.10.0\*(C'\fR. We can then run the bisecting process with:
.PP
.Vb 1
\&  % git bisect run ~/run
.Ve
.PP
When the first bad commit is isolated, \f(CW\*(C`git bisect\*(C'\fR will tell you so:
.PP
.Vb 4
\&  ca4cfd28534303b82a216cfe83a1c80cbc3b9dc5 is first bad commit
\&  commit ca4cfd28534303b82a216cfe83a1c80cbc3b9dc5
\&  Author: Dave Mitchell <davem@fdisolutions.com>
\&  Date:   Sat Feb 9 14:56:23 2008 +0000
\&
\&      [perl #49472] Attributes + Unknown Error
\&      ...
\&
\&  bisect run success
.Ve
.PP
You can peek into the bisecting process with \f(CW\*(C`git bisect log\*(C'\fR and
\&\f(CW\*(C`git bisect visualize\*(C'\fR. \f(CW\*(C`git bisect reset\*(C'\fR will get you out of bisect
mode.
.PP
Please note that the first \f(CW\*(C`good\*(C'\fR state must be an ancestor of the
first \f(CW\*(C`bad\*(C'\fR state. If you want to search for the commit that \fIsolved\fR
some bug, you have to negate your test case (i.e. exit with \f(CW1\fR if \s-1OK\s0
and \f(CW0\fR if not) and still mark the lower bound as \f(CW\*(C`good\*(C'\fR and the
upper as \f(CW\*(C`bad\*(C'\fR. The \*(L"first bad commit\*(R" has then to be understood as
the \*(L"first commit where the bug is solved\*(R".
.PP
\&\f(CW\*(C`git help bisect\*(C'\fR has much more information on how you can tweak your
binary searches.
.SH "SUBMITTING A PATCH VIA GITHUB"
.IX Header "SUBMITTING A PATCH VIA GITHUB"
GitHub is a website that makes it easy to fork and publish projects
with Git. First you should set up a GitHub account and log in.
.PP
Perl's git repository is mirrored on GitHub at this page:
.PP
.Vb 1
\&  http://github.com/github/perl/tree/blead
.Ve
.PP
Visit the page and click the \*(L"fork\*(R" button. This clones the Perl git
repository for you and provides you with \*(L"Your Clone \s-1URL\s0\*(R" from which
you should clone:
.PP
.Vb 1
\&  % git clone git@github.com:USERNAME/perl.git perl\-github
.Ve
.PP
We shall make the same patch as above, creating a new branch:
.PP
.Vb 7
\&  % cd perl\-github
\&  % git remote add upstream git://github.com/github/perl.git
\&  % git pull upstream blead
\&  % git checkout \-b orange
\&  % perl \-pi \-e \*(Aqs{Leon Brocard}{Orange Brocard}\*(Aq AUTHORS
\&  % git commit \-a \-m \*(AqRename Leon Brocard to Orange Brocard\*(Aq
\&  % git push origin orange
.Ve
.PP
The orange branch has been pushed to GitHub, so you should now send an
email to perl5\-porters@perl.org with a description of your changes and
the following information:
.PP
.Vb 2
\&  http://github.com/USERNAME/perl/tree/orange
\&  git@github.com:USERNAME/perl.git branch orange
.Ve
.SH "MERGING FROM A BRANCH VIA GITHUB"
.IX Header "MERGING FROM A BRANCH VIA GITHUB"
If someone has provided a branch via GitHub and you are a committer,
you should use the following in your perl-ssh directory:
.PP
.Vb 2
\&  % git remote add dandv git://github.com/dandv/perl.git
\&  % git fetch
.Ve
.PP
Now you can see the differences between the branch and blead:
.PP
.Vb 1
\&  % git diff dandv/blead
.Ve
.PP
And you can see the commits:
.PP
.Vb 1
\&  % git log dandv/blead
.Ve
.PP
If you approve of a specific commit, you can cherry pick it:
.PP
.Vb 1
\&  % git cherry\-pick 3adac458cb1c1d41af47fc66e67b49c8dec2323f
.Ve
.PP
Or you could just merge the whole branch if you like it all:
.PP
.Vb 1
\&  % git merge dandv/blead
.Ve
.PP
And then push back to the repository:
.PP
.Vb 1
\&  % git push
.Ve
.SH "COMMITTING TO MAINTENANCE VERSIONS"
.IX Header "COMMITTING TO MAINTENANCE VERSIONS"
Maintenance versions should only be altered to add critical bug fixes.
.PP
To commit to a maintenance version of perl, you need to create a local
tracking branch:
.PP
.Vb 1
\&  % git checkout \-\-track \-b maint\-5.005 origin/maint\-5.005
.Ve
.PP
This creates a local branch named \f(CW\*(C`maint\-5.005\*(C'\fR, which tracks the
remote branch \f(CW\*(C`origin/maint\-5.005\*(C'\fR. Then you can pull, commit, merge
and push as before.
.PP
You can also cherry-pick commits from blead and another branch, by
using the \f(CW\*(C`git cherry\-pick\*(C'\fR command. It is recommended to use the
\&\fB\-x\fR option to \f(CW\*(C`git cherry\-pick\*(C'\fR in order to record the \s-1SHA1\s0 of the
original commit in the new commit message.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
The git documentation, accessible via \f(CW\*(C`git help command\*(C'\fR.
