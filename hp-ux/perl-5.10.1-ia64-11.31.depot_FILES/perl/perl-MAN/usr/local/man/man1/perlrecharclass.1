.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLRECHARCLASS 1"
.TH PERLRECHARCLASS 1 "2009-05-14" "perl v5.10.1" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlrecharclass \- Perl Regular Expression Character Classes
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The top level documentation about Perl regular expressions
is found in perlre.
.PP
This manual page discusses the syntax and use of character
classes in Perl Regular Expressions.
.PP
A character class is a way of denoting a set of characters,
in such a way that one character of the set is matched.
It's important to remember that matching a character class
consumes exactly one character in the source string. (The source
string is the string the regular expression is matched against.)
.PP
There are three types of character classes in Perl regular
expressions: the dot, backslashed sequences, and the bracketed form.
.SS "The dot"
.IX Subsection "The dot"
The dot (or period), \f(CW\*(C`.\*(C'\fR is probably the most used, and certainly
the most well-known character class. By default, a dot matches any
character, except for the newline. The default can be changed to
add matching the newline with the \fIsingle line\fR modifier: either
for the entire regular expression using the \f(CW\*(C`/s\*(C'\fR modifier, or
locally using \f(CW\*(C`(?s)\*(C'\fR.
.PP
Here are some examples:
.PP
.Vb 7
\& "a"  =~  /./       # Match
\& "."  =~  /./       # Match
\& ""   =~  /./       # No match (dot has to match a character)
\& "\en" =~  /./       # No match (dot does not match a newline)
\& "\en" =~  /./s      # Match (global \*(Aqsingle line\*(Aq modifier)
\& "\en" =~  /(?s:.)/  # Match (local \*(Aqsingle line\*(Aq modifier)
\& "ab" =~  /^.$/     # No match (dot matches one character)
.Ve
.SS "Backslashed sequences"
.IX Subsection "Backslashed sequences"
Perl regular expressions contain many backslashed sequences that
constitute a character class. That is, they will match a single
character, if that character belongs to a specific set of characters
(defined by the sequence). A backslashed sequence is a sequence of
characters starting with a backslash. Not all backslashed sequences
are character class; for a full list, see perlrebackslash.
.PP
Here's a list of the backslashed sequences, which are discussed in
more detail below.
.PP
.Vb 12
\& \ed             Match a digit character.
\& \eD             Match a non\-digit character.
\& \ew             Match a "word" character.
\& \eW             Match a non\-"word" character.
\& \es             Match a white space character.
\& \eS             Match a non\-white space character.
\& \eh             Match a horizontal white space character.
\& \eH             Match a character that isn\*(Aqt horizontal white space.
\& \ev             Match a vertical white space character.
\& \eV             Match a character that isn\*(Aqt vertical white space.
\& \epP, \ep{Prop}  Match a character matching a Unicode property.
\& \ePP, \eP{Prop}  Match a character that doesn\*(Aqt match a Unicode property.
.Ve
.PP
\fIDigits\fR
.IX Subsection "Digits"
.PP
\&\f(CW\*(C`\ed\*(C'\fR matches a single character that is considered to be a \fIdigit\fR.
What is considered a digit depends on the internal encoding of
the source string. If the source string is in \s-1UTF\-8\s0 format, \f(CW\*(C`\ed\*(C'\fR
not only matches the digits '0' \- '9', but also Arabic, Devanagari and
digits from other languages. Otherwise, if there is a locale in effect,
it will match whatever characters the locale considers digits. Without
a locale, \f(CW\*(C`\ed\*(C'\fR matches the digits '0' to '9'.
See \*(L"Locale, Unicode and \s-1UTF\-8\s0\*(R".
.PP
Any character that isn't matched by \f(CW\*(C`\ed\*(C'\fR will be matched by \f(CW\*(C`\eD\*(C'\fR.
.PP
\fIWord characters\fR
.IX Subsection "Word characters"
.PP
\&\f(CW\*(C`\ew\*(C'\fR matches a single \fIword\fR character: an alphanumeric character
(that is, an alphabetic character, or a digit), or the underscore (\f(CW\*(C`_\*(C'\fR).
What is considered a word character depends on the internal encoding
of the string. If it's in \s-1UTF\-8\s0 format, \f(CW\*(C`\ew\*(C'\fR matches those characters
that are considered word characters in the Unicode database. That is, it
not only matches \s-1ASCII\s0 letters, but also Thai letters, Greek letters, etc.
If the source string isn't in \s-1UTF\-8\s0 format, \f(CW\*(C`\ew\*(C'\fR matches those characters
that are considered word characters by the current locale. Without
a locale in effect, \f(CW\*(C`\ew\*(C'\fR matches the \s-1ASCII\s0 letters, digits and the
underscore.
.PP
Any character that isn't matched by \f(CW\*(C`\ew\*(C'\fR will be matched by \f(CW\*(C`\eW\*(C'\fR.
.PP
\fIWhite space\fR
.IX Subsection "White space"
.PP
\&\f(CW\*(C`\es\*(C'\fR matches any single character that is consider white space. In the
\&\s-1ASCII\s0 range, \f(CW\*(C`\es\*(C'\fR matches the horizontal tab (\f(CW\*(C`\et\*(C'\fR), the new line
(\f(CW\*(C`\en\*(C'\fR), the form feed (\f(CW\*(C`\ef\*(C'\fR), the carriage return (\f(CW\*(C`\er\*(C'\fR), and the
space (the vertical tab, \f(CW\*(C`\ecK\*(C'\fR is not matched by \f(CW\*(C`\es\*(C'\fR).  The exact set
of characters matched by \f(CW\*(C`\es\*(C'\fR depends on whether the source string is
in \s-1UTF\-8\s0 format. If it is, \f(CW\*(C`\es\*(C'\fR matches what is considered white space
in the Unicode database. Otherwise, if there is a locale in effect, \f(CW\*(C`\es\*(C'\fR
matches whatever is considered white space by the current locale. Without
a locale, \f(CW\*(C`\es\*(C'\fR matches the five characters mentioned in the beginning
of this paragraph.  Perhaps the most notable difference is that \f(CW\*(C`\es\*(C'\fR
matches a non-breaking space only if the non-breaking space is in a
\&\s-1UTF\-8\s0 encoded string.
.PP
Any character that isn't matched by \f(CW\*(C`\es\*(C'\fR will be matched by \f(CW\*(C`\eS\*(C'\fR.
.PP
\&\f(CW\*(C`\eh\*(C'\fR will match any character that is considered horizontal white space;
this includes the space and the tab characters. \f(CW\*(C`\eH\*(C'\fR will match any character
that is not considered horizontal white space.
.PP
\&\f(CW\*(C`\ev\*(C'\fR will match any character that is considered vertical white space;
this includes the carriage return and line feed characters (newline).
\&\f(CW\*(C`\eV\*(C'\fR will match any character that is not considered vertical white space.
.PP
\&\f(CW\*(C`\eR\*(C'\fR matches anything that can be considered a newline under Unicode
rules. It's not a character class, as it can match a multi-character
sequence. Therefore, it cannot be used inside a bracketed character
class. Details are discussed in perlrebackslash.
.PP
\&\f(CW\*(C`\eh\*(C'\fR, \f(CW\*(C`\eH\*(C'\fR, \f(CW\*(C`\ev\*(C'\fR, \f(CW\*(C`\eV\*(C'\fR, and \f(CW\*(C`\eR\*(C'\fR are new in perl 5.10.0.
.PP
Note that unlike \f(CW\*(C`\es\*(C'\fR, \f(CW\*(C`\ed\*(C'\fR and \f(CW\*(C`\ew\*(C'\fR, \f(CW\*(C`\eh\*(C'\fR and \f(CW\*(C`\ev\*(C'\fR always match
the same characters, regardless whether the source string is in \s-1UTF\-8\s0
format or not. The set of characters they match is also not influenced
by locale.
.PP
One might think that \f(CW\*(C`\es\*(C'\fR is equivalent with \f(CW\*(C`[\eh\ev]\*(C'\fR. This is not true.
The vertical tab (\f(CW"\ex0b"\fR) is not matched by \f(CW\*(C`\es\*(C'\fR, it is however
considered vertical white space. Furthermore, if the source string is
not in \s-1UTF\-8\s0 format, the next line (\f(CW"\ex85"\fR) and the no-break space
(\f(CW"\exA0"\fR) are not matched by \f(CW\*(C`\es\*(C'\fR, but are by \f(CW\*(C`\ev\*(C'\fR and \f(CW\*(C`\eh\*(C'\fR respectively.
If the source string is in \s-1UTF\-8\s0 format, both the next line and the
no-break space are matched by \f(CW\*(C`\es\*(C'\fR.
.PP
The following table is a complete listing of characters matched by
\&\f(CW\*(C`\es\*(C'\fR, \f(CW\*(C`\eh\*(C'\fR and \f(CW\*(C`\ev\*(C'\fR.
.PP
The first column gives the code point of the character (in hex format),
the second column gives the (Unicode) name. The third column indicates
by which class(es) the character is matched.
.PP
.Vb 10
\& 0x00009        CHARACTER TABULATION   h s
\& 0x0000a              LINE FEED (LF)    vs
\& 0x0000b             LINE TABULATION    v
\& 0x0000c              FORM FEED (FF)    vs
\& 0x0000d        CARRIAGE RETURN (CR)    vs
\& 0x00020                       SPACE   h s
\& 0x00085             NEXT LINE (NEL)    vs  [1]
\& 0x000a0              NO\-BREAK SPACE   h s  [1]
\& 0x01680            OGHAM SPACE MARK   h s
\& 0x0180e   MONGOLIAN VOWEL SEPARATOR   h s
\& 0x02000                     EN QUAD   h s
\& 0x02001                     EM QUAD   h s
\& 0x02002                    EN SPACE   h s
\& 0x02003                    EM SPACE   h s
\& 0x02004          THREE\-PER\-EM SPACE   h s
\& 0x02005           FOUR\-PER\-EM SPACE   h s
\& 0x02006            SIX\-PER\-EM SPACE   h s
\& 0x02007                FIGURE SPACE   h s
\& 0x02008           PUNCTUATION SPACE   h s
\& 0x02009                  THIN SPACE   h s
\& 0x0200a                  HAIR SPACE   h s
\& 0x02028              LINE SEPARATOR    vs
\& 0x02029         PARAGRAPH SEPARATOR    vs
\& 0x0202f       NARROW NO\-BREAK SPACE   h s
\& 0x0205f   MEDIUM MATHEMATICAL SPACE   h s
\& 0x03000           IDEOGRAPHIC SPACE   h s
.Ve
.IP "[1]" 4
.IX Item "[1]"
\&\s-1NEXT\s0 \s-1LINE\s0 and NO-BREAK \s-1SPACE\s0 only match \f(CW\*(C`\es\*(C'\fR if the source string is in
\&\s-1UTF\-8\s0 format.
.PP
It is worth noting that \f(CW\*(C`\ed\*(C'\fR, \f(CW\*(C`\ew\*(C'\fR, etc, match single characters, not
complete numbers or words. To match a number (that consists of integers),
use \f(CW\*(C`\ed+\*(C'\fR; to match a word, use \f(CW\*(C`\ew+\*(C'\fR.
.PP
\fIUnicode Properties\fR
.IX Subsection "Unicode Properties"
.PP
\&\f(CW\*(C`\epP\*(C'\fR and \f(CW\*(C`\ep{Prop}\*(C'\fR are character classes to match characters that
fit given Unicode classes. One letter classes can be used in the \f(CW\*(C`\epP\*(C'\fR
form, with the class name following the \f(CW\*(C`\ep\*(C'\fR, otherwise, the property
name is enclosed in braces, and follows the \f(CW\*(C`\ep\*(C'\fR. For instance, a
match for a number can be written as \f(CW\*(C`/\epN/\*(C'\fR or as \f(CW\*(C`/\ep{Number}/\*(C'\fR.
Lowercase letters are matched by the property \fILowercaseLetter\fR which
has as short form \fILl\fR. They have to be written as \f(CW\*(C`/\ep{Ll}/\*(C'\fR or
\&\f(CW\*(C`/\ep{LowercaseLetter}/\*(C'\fR. \f(CW\*(C`/\epLl/\*(C'\fR is valid, but means something different.
It matches a two character string: a letter (Unicode property \f(CW\*(C`\epL\*(C'\fR),
followed by a lowercase \f(CW\*(C`l\*(C'\fR.
.PP
For a list of possible properties, see
\&\*(L"Unicode Character Properties\*(R" in perlunicode. It is also possible to
defined your own properties. This is discussed in
\&\*(L"User-Defined Character Properties\*(R" in perlunicode.
.PP
Examples
.IX Subsection "Examples"
.PP
.Vb 8
\& "a"  =~  /\ew/      # Match, "a" is a \*(Aqword\*(Aq character.
\& "7"  =~  /\ew/      # Match, "7" is a \*(Aqword\*(Aq character as well.
\& "a"  =~  /\ed/      # No match, "a" isn\*(Aqt a digit.
\& "7"  =~  /\ed/      # Match, "7" is a digit.
\& " "  =~  /\es/      # Match, a space is white space.
\& "a"  =~  /\eD/      # Match, "a" is a non\-digit.
\& "7"  =~  /\eD/      # No match, "7" is not a non\-digit.
\& " "  =~  /\eS/      # No match, a space is not non\-white space.
\&
\& " "  =~  /\eh/      # Match, space is horizontal white space.
\& " "  =~  /\ev/      # No match, space is not vertical white space.
\& "\er" =~  /\ev/      # Match, a return is vertical white space.
\&
\& "a"  =~  /\epL/     # Match, "a" is a letter.
\& "a"  =~  /\ep{Lu}/  # No match, /\ep{Lu}/ matches upper case letters.
\&
\& "\ex{0e0b}" =~ /\ep{Thai}/  # Match, \ex{0e0b} is the character
\&                           # \*(AqTHAI CHARACTER SO SO\*(Aq, and that\*(Aqs in
\&                           # Thai Unicode class.
\& "a"  =~  /\eP{Lao}/ # Match, as "a" is not a Laoian character.
.Ve
.SS "Bracketed Character Classes"
.IX Subsection "Bracketed Character Classes"
The third form of character class you can use in Perl regular expressions
is the bracketed form. In its simplest form, it lists the characters
that may be matched inside square brackets, like this: \f(CW\*(C`[aeiou]\*(C'\fR.
This matches one of \f(CW\*(C`a\*(C'\fR, \f(CW\*(C`e\*(C'\fR, \f(CW\*(C`i\*(C'\fR, \f(CW\*(C`o\*(C'\fR or \f(CW\*(C`u\*(C'\fR. Just as the other
character classes, exactly one character will be matched. To match
a longer string consisting of characters mentioned in the characters
class, follow the character class with a quantifier. For instance,
\&\f(CW\*(C`[aeiou]+\*(C'\fR matches a string of one or more lowercase \s-1ASCII\s0 vowels.
.PP
Repeating a character in a character class has no
effect; it's considered to be in the set only once.
.PP
Examples:
.PP
.Vb 5
\& "e"  =~  /[aeiou]/        # Match, as "e" is listed in the class.
\& "p"  =~  /[aeiou]/        # No match, "p" is not listed in the class.
\& "ae" =~  /^[aeiou]$/      # No match, a character class only matches
\&                           # a single character.
\& "ae" =~  /^[aeiou]+$/     # Match, due to the quantifier.
.Ve
.PP
\fISpecial Characters Inside a Bracketed Character Class\fR
.IX Subsection "Special Characters Inside a Bracketed Character Class"
.PP
Most characters that are meta characters in regular expressions (that
is, characters that carry a special meaning like \f(CW\*(C`*\*(C'\fR or \f(CW\*(C`(\*(C'\fR) lose
their special meaning and can be used inside a character class without
the need to escape them. For instance, \f(CW\*(C`[()]\*(C'\fR matches either an opening
parenthesis, or a closing parenthesis, and the parens inside the character
class don't group or capture.
.PP
Characters that may carry a special meaning inside a character class are:
\&\f(CW\*(C`\e\*(C'\fR, \f(CW\*(C`^\*(C'\fR, \f(CW\*(C`\-\*(C'\fR, \f(CW\*(C`[\*(C'\fR and \f(CW\*(C`]\*(C'\fR, and are discussed below. They can be
escaped with a backslash, although this is sometimes not needed, in which
case the backslash may be omitted.
.PP
The sequence \f(CW\*(C`\eb\*(C'\fR is special inside a bracketed character class. While
outside the character class \f(CW\*(C`\eb\*(C'\fR is an assertion indicating a point
that does not have either two word characters or two non-word characters
on either side, inside a bracketed character class, \f(CW\*(C`\eb\*(C'\fR matches a
backspace character.
.PP
A \f(CW\*(C`[\*(C'\fR is not special inside a character class, unless it's the start
of a \s-1POSIX\s0 character class (see below). It normally does not need escaping.
.PP
A \f(CW\*(C`]\*(C'\fR is either the end of a \s-1POSIX\s0 character class (see below), or it
signals the end of the bracketed character class. Normally it needs
escaping if you want to include a \f(CW\*(C`]\*(C'\fR in the set of characters.
However, if the \f(CW\*(C`]\*(C'\fR is the \fIfirst\fR (or the second if the first
character is a caret) character of a bracketed character class, it
does not denote the end of the class (as you cannot have an empty class)
and is considered part of the set of characters that can be matched without
escaping.
.PP
Examples:
.PP
.Vb 8
\& "+"   =~ /[+?*]/     #  Match, "+" in a character class is not special.
\& "\ecH" =~ /[\eb]/      #  Match, \eb inside in a character class
\&                      #  is equivalent with a backspace.
\& "]"   =~ /[][]/      #  Match, as the character class contains.
\&                      #  both [ and ].
\& "[]"  =~ /[[]]/      #  Match, the pattern contains a character class
\&                      #  containing just ], and the character class is
\&                      #  followed by a ].
.Ve
.PP
\fICharacter Ranges\fR
.IX Subsection "Character Ranges"
.PP
It is not uncommon to want to match a range of characters. Luckily, instead
of listing all the characters in the range, one may use the hyphen (\f(CW\*(C`\-\*(C'\fR).
If inside a bracketed character class you have two characters separated
by a hyphen, it's treated as if all the characters between the two are in
the class. For instance, \f(CW\*(C`[0\-9]\*(C'\fR matches any \s-1ASCII\s0 digit, and \f(CW\*(C`[a\-m]\*(C'\fR
matches any lowercase letter from the first half of the \s-1ASCII\s0 alphabet.
.PP
Note that the two characters on either side of the hyphen are not
necessary both letters or both digits. Any character is possible,
although not advisable.  \f(CW\*(C`[\*(Aq\-?]\*(C'\fR contains a range of characters, but
most people will not know which characters that will be. Furthermore,
such ranges may lead to portability problems if the code has to run on
a platform that uses a different character set, such as \s-1EBCDIC\s0.
.PP
If a hyphen in a character class cannot be part of a range, for instance
because it is the first or the last character of the character class,
or if it immediately follows a range, the hyphen isn't special, and will be
considered a character that may be matched. You have to escape the hyphen
with a backslash if you want to have a hyphen in your set of characters to
be matched, and its position in the class is such that it can be considered
part of a range.
.PP
Examples:
.PP
.Vb 8
\& [a\-z]       #  Matches a character that is a lower case ASCII letter.
\& [a\-fz]      #  Matches any letter between \*(Aqa\*(Aq and \*(Aqf\*(Aq (inclusive) or the
\&             #  letter \*(Aqz\*(Aq.
\& [\-z]        #  Matches either a hyphen (\*(Aq\-\*(Aq) or the letter \*(Aqz\*(Aq.
\& [a\-f\-m]     #  Matches any letter between \*(Aqa\*(Aq and \*(Aqf\*(Aq (inclusive), the
\&             #  hyphen (\*(Aq\-\*(Aq), or the letter \*(Aqm\*(Aq.
\& [\*(Aq\-?]       #  Matches any of the characters  \*(Aq()*+,\-./0123456789:;<=>?
\&             #  (But not on an EBCDIC platform).
.Ve
.PP
\fINegation\fR
.IX Subsection "Negation"
.PP
It is also possible to instead list the characters you do not want to
match. You can do so by using a caret (\f(CW\*(C`^\*(C'\fR) as the first character in the
character class. For instance, \f(CW\*(C`[^a\-z]\*(C'\fR matches a character that is not a
lowercase \s-1ASCII\s0 letter.
.PP
This syntax make the caret a special character inside a bracketed character
class, but only if it is the first character of the class. So if you want
to have the caret as one of the characters you want to match, you either
have to escape the caret, or not list it first.
.PP
Examples:
.PP
.Vb 4
\& "e"  =~  /[^aeiou]/   #  No match, the \*(Aqe\*(Aq is listed.
\& "x"  =~  /[^aeiou]/   #  Match, as \*(Aqx\*(Aq isn\*(Aqt a lowercase vowel.
\& "^"  =~  /[^^]/       #  No match, matches anything that isn\*(Aqt a caret.
\& "^"  =~  /[x^]/       #  Match, caret is not special here.
.Ve
.PP
\fIBackslash Sequences\fR
.IX Subsection "Backslash Sequences"
.PP
You can put a backslash sequence character class inside a bracketed character
class, and it will act just as if you put all the characters matched by
the backslash sequence inside the character class. For instance,
\&\f(CW\*(C`[a\-f\ed]\*(C'\fR will match any digit, or any of the lowercase letters between
\&'a' and 'f' inclusive.
.PP
Examples:
.PP
.Vb 4
\& /[\ep{Thai}\ed]/     # Matches a character that is either a Thai
\&                    # character, or a digit.
\& /[^\ep{Arabic}()]/  # Matches a character that is neither an Arabic
\&                    # character, nor a parenthesis.
.Ve
.PP
Backslash sequence character classes cannot form one of the endpoints
of a range.
.PP
\fIPosix Character Classes\fR
.IX Subsection "Posix Character Classes"
.PP
Posix character classes have the form \f(CW\*(C`[:class:]\*(C'\fR, where \fIclass\fR is
name, and the \f(CW\*(C`[:\*(C'\fR and \f(CW\*(C`:]\*(C'\fR delimiters. Posix character classes appear
\&\fIinside\fR bracketed character classes, and are a convenient and descriptive
way of listing a group of characters. Be careful about the syntax,
.PP
.Vb 2
\& # Correct:
\& $string =~ /[[:alpha:]]/
\&
\& # Incorrect (will warn):
\& $string =~ /[:alpha:]/
.Ve
.PP
The latter pattern would be a character class consisting of a colon,
and the letters \f(CW\*(C`a\*(C'\fR, \f(CW\*(C`l\*(C'\fR, \f(CW\*(C`p\*(C'\fR and \f(CW\*(C`h\*(C'\fR.
.PP
Perl recognizes the following \s-1POSIX\s0 character classes:
.PP
.Vb 10
\& alpha  Any alphabetical character.
\& alnum  Any alphanumerical character.
\& ascii  Any ASCII character.
\& blank  A GNU extension, equal to a space or a horizontal tab ("\et").
\& cntrl  Any control character.
\& digit  Any digit, equivalent to "\ed".
\& graph  Any printable character, excluding a space.
\& lower  Any lowercase character.
\& print  Any printable character, including a space.
\& punct  Any punctuation character.
\& space  Any white space character. "\es" plus the vertical tab ("\ecK").
\& upper  Any uppercase character.
\& word   Any "word" character, equivalent to "\ew".
\& xdigit Any hexadecimal digit, \*(Aq0\*(Aq \- \*(Aq9\*(Aq, \*(Aqa\*(Aq \- \*(Aqf\*(Aq, \*(AqA\*(Aq \- \*(AqF\*(Aq.
.Ve
.PP
The exact set of characters matched depends on whether the source string
is internally in \s-1UTF\-8\s0 format or not. See \*(L"Locale, Unicode and \s-1UTF\-8\s0\*(R".
.PP
Most \s-1POSIX\s0 character classes have \f(CW\*(C`\ep\*(C'\fR counterparts. The difference
is that the \f(CW\*(C`\ep\*(C'\fR classes will always match according to the Unicode
properties, regardless whether the string is in \s-1UTF\-8\s0 format or not.
.PP
The following table shows the relation between \s-1POSIX\s0 character classes
and the Unicode properties:
.PP
.Vb 1
\& [[:...:]]   \ep{...}      backslash
\&
\& alpha       IsAlpha
\& alnum       IsAlnum
\& ascii       IsASCII
\& blank
\& cntrl       IsCntrl
\& digit       IsDigit      \ed
\& graph       IsGraph
\& lower       IsLower
\& print       IsPrint
\& punct       IsPunct
\& space       IsSpace
\&             IsSpacePerl  \es
\& upper       IsUpper
\& word        IsWord
\& xdigit      IsXDigit
.Ve
.PP
Some character classes may have a non-obvious name:
.IP "cntrl" 4
.IX Item "cntrl"
Any control character. Usually, control characters don't produce output
as such, but instead control the terminal somehow: for example newline
and backspace are control characters. All characters with \f(CW\*(C`ord()\*(C'\fR less
than 32 are usually classified as control characters (in \s-1ASCII\s0, the \s-1ISO\s0
Latin character sets, and Unicode), as is the character \f(CW\*(C`ord()\*(C'\fR value
of 127 (\f(CW\*(C`DEL\*(C'\fR).
.IP "graph" 4
.IX Item "graph"
Any character that is \fIgraphical\fR, that is, visible. This class consists
of all the alphanumerical characters and all punctuation characters.
.IP "print" 4
.IX Item "print"
All printable characters, which is the set of all the graphical characters
plus the space.
.IP "punct" 4
.IX Item "punct"
Any punctuation (special) character.
.PP
Negation
.IX Subsection "Negation"
.PP
A Perl extension to the \s-1POSIX\s0 character class is the ability to
negate it. This is done by prefixing the class name with a caret (\f(CW\*(C`^\*(C'\fR).
Some examples:
.PP
.Vb 4
\& POSIX         Unicode       Backslash
\& [[:^digit:]]  \eP{IsDigit}   \eD
\& [[:^space:]]  \eP{IsSpace}   \eS
\& [[:^word:]]   \eP{IsWord}    \eW
.Ve
.PP
[= =] and [. .]
.IX Subsection "[= =] and [. .]"
.PP
Perl will recognize the \s-1POSIX\s0 character classes \f(CW\*(C`[=class=]\*(C'\fR, and
\&\f(CW\*(C`[.class.]\*(C'\fR, but does not (yet?) support this construct. Use of
such a construct will lead to an error.
.PP
Examples
.IX Subsection "Examples"
.PP
.Vb 10
\& /[[:digit:]]/            # Matches a character that is a digit.
\& /[01[:lower:]]/          # Matches a character that is either a
\&                          # lowercase letter, or \*(Aq0\*(Aq or \*(Aq1\*(Aq.
\& /[[:digit:][:^xdigit:]]/ # Matches a character that can be anything,
\&                          # but the letters \*(Aqa\*(Aq to \*(Aqf\*(Aq in either case.
\&                          # This is because the character class contains
\&                          # all digits, and anything that isn\*(Aqt a
\&                          # hex digit, resulting in a class containing
\&                          # all characters, but the letters \*(Aqa\*(Aq to \*(Aqf\*(Aq
\&                          # and \*(AqA\*(Aq to \*(AqF\*(Aq.
.Ve
.SS "Locale, Unicode and \s-1UTF\-8\s0"
.IX Subsection "Locale, Unicode and UTF-8"
Some of the character classes have a somewhat different behaviour depending
on the internal encoding of the source string, and the locale that is
in effect.
.PP
\&\f(CW\*(C`\ew\*(C'\fR, \f(CW\*(C`\ed\*(C'\fR, \f(CW\*(C`\es\*(C'\fR and the \s-1POSIX\s0 character classes (and their negations,
including \f(CW\*(C`\eW\*(C'\fR, \f(CW\*(C`\eD\*(C'\fR, \f(CW\*(C`\eS\*(C'\fR) suffer from this behaviour.
.PP
The rule is that if the source string is in \s-1UTF\-8\s0 format, the character
classes match according to the Unicode properties. If the source string
isn't, then the character classes match according to whatever locale is
in effect. If there is no locale, they match the \s-1ASCII\s0 defaults
(52 letters, 10 digits and underscore for \f(CW\*(C`\ew\*(C'\fR, 0 to 9 for \f(CW\*(C`\ed\*(C'\fR, etc).
.PP
This usually means that if you are matching against characters whose \f(CW\*(C`ord()\*(C'\fR
values are between 128 and 255 inclusive, your character class may match
or not depending on the current locale, and whether the source string is
in \s-1UTF\-8\s0 format. The string will be in \s-1UTF\-8\s0 format if it contains
characters whose \f(CW\*(C`ord()\*(C'\fR value exceeds 255. But a string may be in \s-1UTF\-8\s0
format without it having such characters.
.PP
For portability reasons, it may be better to not use \f(CW\*(C`\ew\*(C'\fR, \f(CW\*(C`\ed\*(C'\fR, \f(CW\*(C`\es\*(C'\fR
or the \s-1POSIX\s0 character classes, and use the Unicode properties instead.
.PP
Examples
.IX Subsection "Examples"
.PP
.Vb 6
\& $str =  "\exDF";      # $str is not in UTF\-8 format.
\& $str =~ /^\ew/;       # No match, as $str isn\*(Aqt in UTF\-8 format.
\& $str .= "\ex{0e0b}";  # Now $str is in UTF\-8 format.
\& $str =~ /^\ew/;       # Match! $str is now in UTF\-8 format.
\& chop $str;
\& $str =~ /^\ew/;       # Still a match! $str remains in UTF\-8 format.
.Ve
